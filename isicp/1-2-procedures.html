<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
<meta charset="UTF-8">

<script src="biwascheme.js"> </script>
<script src="codemirror/lib/codemirror.js"></script>
<script src="codemirror/mode/scheme/scheme.js"></script>
<script src="jquery.min.js"></script>
<script src="coding.js"> </script>
<script src="isicp.js"> </script>

<link rel="stylesheet" type="text/css" href="codemirror.css" />
<link rel="stylesheet" type="text/css" href="isicp.css" />

<title>iSICP 1.2 - Procedures and the Processes They Generate</title>
</head>
<body>

<h2> Procedures and the Processes They Generate </h2>

<div id="sidebox">
  <div class="tab"></div>
  <div class="content">
    
    <p>
    
    <div id="scheme-scratch">(+ 1 2)</div> 
    <script>
    prompt("scheme-scratch"); 
    </script>
  
    <div id="currently-editing"> </div>
    
    <p> Video Lectures: 
    <a href='http://www.youtube.com/watch?v=2Op3QLzMgSY' title="Overview and Introduction to Lisp"> 1A </a> &nbsp;
    <a href='http://www.youtube.com/watch?v=dlbMuv-jix8' title="Procedures and Processes; Substitution Model"> 1B  </a>
        
  
  </div>
</div>

<script> 
$('#sidebox .tab').toggle(function(){
    $('#sidebox').animate({'right':0});
}, function(){
    $('#sidebox').animate({'right':'-30%'});
});
</script>

<div id="main">

<p> We have now considered the elements of programming: We have used primitive arithmetic operations, we have combined these operations, and we have abstracted these composite operations by defining them as compound procedures. But that is not enough to enable us to say that we know how to program. Our situation is analogous to that of someone who has learned the rules for how the pieces move in chess but knows nothing of typical openings, tactics, or strategy. Like the novice chess player, we don't yet know the common patterns of usage in the domain. We lack the knowledge of which moves are worth making (which procedures are worth defining). We lack the experience to predict the consequences of making a move (executing a procedure).

<p> The ability to visualize the consequences of the actions under consideration is crucial to becoming an expert programmer, just as it is in any synthetic, creative activity. In becoming an expert photographer, for example, one must learn how to look at a scene and know how dark each region will appear on a print for each possible choice of exposure and development conditions. Only then can one reason backward, planning framing, lighting, exposure, and development to obtain the desired effects. So it is with programming, where we are planning the course of action to be taken by a process and where we control the process by means of a program. To become experts, we must learn to visualize the processes generated by various types of procedures. Only after we have developed such a skill can we learn to reliably construct programs that exhibit the desired behavior.

<p> A procedure is a pattern for the local evolution of a computational process. It specifies how each stage of the process is built upon the previous stage. We would like to be able to make statements about the overall, or global, behavior of a process whose local evolution has been specified by a procedure. This is very difficult to do in general, but we can at least try to describe some typical patterns of process evolution.

<p> In this section we will examine some common ``shapes'' for processes generated by simple procedures. We will also investigate the rates at which these processes consume the important computational resources of time and space. The procedures we will consider are very simple. Their role is like that played by test patterns in photography: as oversimplified prototypical patterns, rather than practical examples in their own right.

<h3> Linear Recursion and Iteration </h3>

<p> <img src="http://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-7.gif"> </img> <br>
<p> <b> Figure 1.3: </b>  A linear recursive process for computing 6!.

<p> We begin by considering the factorial function, defined by

<p> <img src="http://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-8.gif"> </img> <br>

There are many ways to compute factorials. One way is to make use of the observation that n! is equal to n times (n - 1)! for any positive integer n:

<p> <img src="http://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-9.gif"> </img> <br>

Thus, we can compute n! by computing (n - 1)! and multiplying the result by n. If we add the stipulation that 1! is equal to 1, this observation translates directly into a procedure:




</div>

<script> 
for (var _e in editorOf) {
  editorOf[_e].getOption("onBlur")();
}
</script>

</body>
</html>
