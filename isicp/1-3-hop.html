<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
<meta charset="UTF-8">

<link rel="stylesheet" type="text/css" href="codemirror.css" />
<link rel="stylesheet" type="text/css" href="isicp.css" />
<link rel="stylesheet" type="text/css" href="footnote/footnote.css" />
<link rel="stylesheet" type="text/css" href="theme.css" />

<script src="biwascheme.js"> </script>
<script src="codemirror/lib/codemirror.js"></script>
<script src="codemirror/mode/scheme/scheme.js"></script>
<script src="jquery.min.js"></script>
<script src="coding.js"> </script>
<script src="footnote/tooltip.js"></script>
<script src="footnote/tooltip.dynamic.js"></script>
<script src="footnote/footnote.js"></script>

<title>iSICP 1.3 - Higher-Order Procedures</title>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-36868476-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>

<h2 style="width: 60%"> Formulating Abstractions with Higher-Order Procedures </h2>

<div id="sidebox">
  <div class="tab"></div>
  <div class="content">
    
    <p> <a href="index.html">Back to Contents</a>
    
    <div id="scheme-scratch">(+ 1 2)</div> 
    <script>
    prompt("scheme-scratch"); 
    
    var deferDraw = (location.hash == "");
    if (deferDraw) {
      $("body").hide();
    }
    </script>
  
    <div id="currently-editing"> </div>
    
    <p>
    
    <div id="toc"> </div>
    
    <p> Video Lectures: 
    <a href='http://www.youtube.com/watch?v=2Op3QLzMgSY' title="Overview and Introduction to Lisp"> 1A </a> &nbsp;
    <a href='http://www.youtube.com/watch?v=dlbMuv-jix8' title="Procedures and Processes; Substitution Model"> 1B  </a>
    
    <p style='font-size:12px'> (Click on the left edge of this green box to hide it!)
        
  
  </div>
</div>

<script> 
$('#sidebox .tab').toggle(function(){
    $('#sidebox').animate({'right':'0%'});
}, function(){
    $('#sidebox').animate({'right':'-30%'});
});

$(document).ready(createTOC);

</script>

<div id="main">

<p> We have seen that procedures are, in effect, abstractions that describe compound operations on numbers independent of the particular numbers. For example, when we

<div id="scheme-define-cube">
(define (cube x) (* x x x))
</div>
<script>
prompt("scheme-define-cube");
</script>

<p> we are not talking about the cube of a particular number, but rather about a method for obtaining the cube of any number. Of course we could get along without ever defining this procedure, by always writing expressions such as

<div id="scheme-cube-ex">
(* 3 3 3)
(* x x x)
(* y y y)
</div>
<script>
prompt("scheme-cube-ex");
</script>

<p> and never mentioning cube explicitly. This would place us at a serious disadvantage, forcing us to work always at the level of the particular operations that happen to be primitives in the language (multiplication, in this case) rather than in terms of higher-level operations. Our programs would be able to compute cubes, but our language would lack the ability to express the concept of cubing. One of the things we should demand from a powerful programming language is the ability to build abstractions by assigning names to common patterns and then to work in terms of the abstractions directly. Procedures provide this ability. This is why all but the most primitive programming languages include mechanisms for defining procedures.

<p> Yet even in numerical processing we will be severely limited in our ability to create abstractions if we are restricted to procedures whose parameters must be numbers. Often the same programming pattern will be used with a number of different procedures. To express such patterns as concepts, we will need to construct procedures that can accept procedures as arguments or return procedures as values. Procedures that manipulate procedures are called higher-order procedures. This section shows how higher-order procedures can serve as powerful abstraction mechanisms, vastly increasing the expressive power of our language.

<h3> Procedures as Arguments </h3>

<p> Consider the following three procedures. The first computes the sum of the integers from a through b:

<div id="scheme-define-sum-integers">
(define (sum-integers a b)
  (if (&gt; a b)
      0
      (+ a (sum-integers (+ a 1) b))))
</div>
<script>
prompt("scheme-define-sum-integers");
</script>

<p> The second computes the sum of the cubes of the integers in the given range:

<div id="scheme-define-sum-cubes">
(define (sum-cubes a b)
  (if (&gt; a b)
      0
      (+ (cube a) (sum-cubes (+ a 1) b))))
</div>
<script>
prompt("scheme-define-sum-cubes");
depsOf["scheme-define-sum-cubes"] = ["scheme-define-cube"];
</script>

<p> The third computes the sum of a sequence of terms in the series

<p> <img src='http://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-26.gif'>

<p> which converges to pi/8 (very slowly):49

<div id="scheme-define-pi-sum">
(define (pi-sum a b)
  (if (&gt; a b)
      0
      (+ (/ 1.0 (* a (+ a 2))) (pi-sum (+ a 4) b))))
</div>
<script>
prompt("scheme-define-pi-sum");
</script>

<p> These three procedures clearly share a common underlying pattern. They are for the most part identical, differing only in the name of the procedure, the function of a used to compute the term to be added, and the function that provides the next value of a. We could generate each of the procedures by filling in slots in the same template:

<div id="scheme-sum-template">
(define (&lt;name&gt; a b)
  (if (&gt; a b)
      0
      (+ (&lt;term&gt; a)
         (&lt;name&gt; (&lt;next&gt; a) b))))
</div>
<script>
prompt("scheme-sum-template");
</script>

<p> The presence of such a common pattern is strong evidence that there is a useful abstraction waiting to be brought to the surface. Indeed, mathematicians long ago identified the abstraction of summation of a series and invented ``sigma notation,'' for example

<p> <img src='http://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-27.gif'>

<p> to express this concept. The power of sigma notation is that it allows mathematicians to deal with the concept of summation itself rather than only with particular sums -- for example, to formulate general results about sums that are independent of the particular series being summed.

<p> Similarly, as program designers, we would like our language to be powerful enough so that we can write a procedure that expresses the concept of summation itself rather than only procedures that compute particular sums. We can do so readily in our procedural language by taking the common template shown above and transforming the ``slots'' into formal parameters:

<div id="scheme-define-sum">
(define (sum term a next b)
  (if (&gt; a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
</div>
<script>
prompt("scheme-define-sum");
</script>

<p> Notice that sum takes as its arguments the lower and upper bounds a and b together with the procedures term and next. We can use sum just as we would any procedure. For example, we can use it (along with a procedure inc that increments its argument by 1) to define sum-cubes:

<div id="scheme-define-inc">
(define (inc n) (+ n 1))
</div>
<script>
prompt("scheme-define-inc");
</script>

<div id="scheme-define-sum-cubes-sum">

(define (sum-cubes a b)
  (sum cube a inc b))
</div>
<script>
prompt("scheme-define-sum-cubes-sum");
depsOf["scheme-define-sum-cubes-sum"] = ["scheme-define-cube", "scheme-define-inc", "scheme-define-sum"];
</script>

<p> Using this, we can compute the sum of the cubes of the integers from 1 to 10:

<div id="scheme-sum-cubes-1-10">
(sum-cubes 1 10)
</div>
<script>
prompt("scheme-sum-cubes-1-10");
depsOf["scheme-sum-cubes-1-10"] = ["scheme-define-sum-cubes-sum"];
</script>

<p> With the aid of an identity procedure to compute the term, we can define sum-integers in terms of sum:

<div id="scheme-define-sum-integers-sum">
(define (identity x) x)

(define (sum-integers a b)
  (sum identity a inc b))
</div>
<script>
prompt("scheme-define-sum-integers-sum");
depsOf["scheme-define-sum-integers-sum"] = ["scheme-define-inc", "scheme-define-sum"];
</script>

<p> Then we can add up the integers from 1 to 10:

<div id="scheme-sum-integers-1-10">
(sum-integers 1 10)
</div>
<script>
prompt("scheme-sum-integers-1-10");
depsOf["scheme-sum-integers-1-10"] = ["scheme-define-sum-integers-sum"];
</script>

<p> We can also define pi-sum in the same way:50

<div id="scheme-define-pi-sum-sum">
(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))
</div>
<script>
prompt("scheme-define-pi-sum-sum");
depsOf["scheme-define-pi-sum-sum"] = ["scheme-define-sum"];
</script>

<p> Using these procedures, we can compute an approximation to  :

<div id="scheme-pi-sum-pi">
(* 8 (pi-sum 1 1000))
</div>
<script>
prompt("scheme-pi-sum-pi");
depsOf["scheme-pi-sum-pi"] = ["scheme-define-pi-sum-sum"];
</script>

<p> Once we have sum, we can use it as a building block in formulating further concepts. For instance, the definite integral of a function f between the limits a and b can be approximated numerically using the formula

<p> <img src='http://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-28.gif'>

<p> for small values of dx. We can express this directly as a procedure:

<div id="scheme-define-integral">
(define (integral f a b dx)
  (define (add-dx x) (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))
</div>
<script>
prompt("scheme-define-integral");
depsOf["scheme-define-integral"] = ["scheme-define-sum"];
</script>

<p>

<div id="scheme-integral-cube">
(integral cube 0 1 0.01)
</div>

<p>

<div id="scheme-integral-cube-finer">
(integral cube 0 1 0.001)
</div>
<script>
prompt("scheme-integral-cube");
depsOf["scheme-integral-cube"] = ["scheme-define-cube", "scheme-define-integral"];
prompt("scheme-integral-cube-finer");
depsOf["scheme-integral-cube-finer"] = ["scheme-define-cube", "scheme-define-integral"];
</script>

<p> (The exact value of the integral of cube between 0 and 1 is 1/4.)

<div class="exercise">
<p> <b> Exercise 1.29. </b> Simpson's Rule is a more accurate method of numerical integration than the method illustrated above. Using Simpson's Rule, the integral of a function f between a and b is approximated as

<p> <img src='http://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-29.gif'>

<p> where h = (b - a)/n, for some even integer n, and yk = f(a + kh). (Increasing n increases the accuracy of the approximation.) Define a procedure that takes as arguments f, a, b, and n and returns the value of the integral, computed using Simpson's Rule. Use your procedure to integrate cube between 0 and 1 (with n = 100 and n = 1000), and compare the results to those of the integral procedure shown above.

</div>

<p>

<div class="exercise">
<p> <b> Exercise 1.30. </b> The sum procedure above generates a linear recursion. The procedure can be rewritten so that the sum is performed iteratively. Show how to do this by filling in the missing expressions in the following definition:

(define (sum term a next b)
  (define (iter a result)
    (if <??>
        <??>
        (iter <??> <??>)))
  (iter <??> <??>))
  
</div>

<p>

<div class="exercise">
<p> <b> Exercise 1.31. </b>

<ol style="list-style-type: lower-alpha">
<li>
The sum procedure is only the simplest of a vast number of similar abstractions that can be captured as higher-order procedures.51 Write an analogous procedure called product that returns the product of the values of a function at points over a given range. Show how to define factorial in terms of product. Also use product to compute approximations to  using the formula52

<p> <img src='http://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-30.gif'>
</li>

<li>
If your product procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.
</li>
</ol>
</div>

<div class="exercise">
<p> <b> Exercise 1.32. </b>

<ol style="list-style-type: lower-alpha">
<li>
<p> Show that sum and product (exercise 1.31) are both special cases of a still more general notion called accumulate that combines a collection of terms, using some general accumulation function:

<div id="scheme-accumulate-signature">
(accumulate combiner null-value term a next b)
</div>
<script>
prompt("scheme-accumulate-signature");
</script>

<p> Accumulate takes as arguments the same term and range specifications as sum and product, together with a combiner procedure (of two arguments) that specifies how the current term is to be combined with the accumulation of the preceding terms and a null-value that specifies what base value to use when the terms run out. Write accumulate and show how sum and product can both be defined as simple calls to accumulate. Write two procedures, one that generates a recursive process and one iterative.

</div>

<div class="exercise">
<p> <b> Exercise 1.33. </b> You can obtain an even more general version of accumulate (exercise 1.32) by introducing the notion of a filter on the terms to be combined. That is, combine only those terms derived from values in the range that satisfy a specified condition. The resulting filtered-accumulate abstraction takes the same arguments as accumulate, together with an additional predicate of one argument that specifies the filter. Write filtered-accumulate as a procedure. Show how to express the following using filtered-accumulate:

<ol style="list-style-type: lower-alpha">
<li>
the sum of the squares of the prime numbers in the interval a to b (assuming that you have a prime? predicate already written)
</li>

<li>
the product of all the positive integers less than n that are relatively prime to n (i.e., all positive integers i &lt; n such that GCD(i,n) = 1).
</li>
</ol>

</div>

<h3> Constructing Procedures Using Lambda </h3>

<p> In using sum as in section 1.3.1, it seems terribly awkward to have to define trivial procedures such as pi-term and pi-next just so we can use them as arguments to our higher-order procedure. Rather than define pi-next and pi-term, it would be more convenient to have a way to directly specify ``the procedure that returns its input incremented by 4'' and ``the procedure that returns the reciprocal of its input times its input plus 2.'' We can do this by introducing the special form lambda, which creates procedures. Using lambda we can describe what we want as

<div id="scheme-lambda-plus-4">
(lambda (x) (+ x 4))
</div>
<script>
prompt("scheme-lambda-plus-4");
</script>

<p> and

<div id="scheme-lambda-inv-poly">
(lambda (x) (/ 1.0 (* x (+ x 2))))
</div>
<script>
prompt("scheme-lambda-inv-poly");
</script>

<p> Then our pi-sum procedure can be expressed without defining any auxiliary procedures as

(define (pi-sum a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
       a
       (lambda (x) (+ x 4))
       b))

Again using lambda, we can write the integral procedure without having to define the auxiliary procedure add-dx:

(define (integral f a b dx)
  (* (sum f
          (+ a (/ dx 2.0))
          (lambda (x) (+ x dx))
          b)
     dx))

In general, lambda is used to create procedures in the same way as define, except that no name is specified for the procedure:

(lambda (<formal-parameters>) <body>)

The resulting procedure is just as much a procedure as one that is created using define. The only difference is that it has not been associated with any name in the environment. In fact,


(define (plus4 x) (+ x 4))

is equivalent to

(define plus4 (lambda (x) (+ x 4)))

<p> We can read a lambda expression as follows:

<p><p><tt>&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0"><br>
&nbsp;the&nbsp;procedure&nbsp;&nbsp;&nbsp;of&nbsp;an&nbsp;argument&nbsp;<tt>x</tt>&nbsp;&nbsp;that&nbsp;adds&nbsp;&nbsp;<tt>x</tt>&nbsp;and&nbsp;4<br>
</tt><p><p>

Like any expression that has a procedure as its value, a lambda expression can be used as the operator in a combination such as

((lambda (x y z) (+ x y (square z))) 1 2 3)
12

or, more generally, in any context where we would normally use a procedure name.53




<hr>

<p> <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/InteractiveResource" property="dct:title" rel="dct:type">Interactive SICP</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="http://mitpress.mit.edu/sicp/" rel="dct:source">http://mitpress.mit.edu/sicp/</a>.

</div>

<script> 

for (var _e in editorOf) {
  editorOf[_e].getOption("onBlur")();
}

if (deferDraw) {
  $("body").show();
  var todo = [];
  for (var _e in editorOf) {
    todo.push(editorOf[_e]);
  }

  setTimeout(function() {
    var e = todo.shift();
    e.refresh();
    
    if (todo.length > 0) {
      setTimeout(arguments.callee, 25);
    }
  }, 25);
}

if (!deferDraw) {
  $(function () {
    $('html, body').animate({
      scrollTop: $(location.hash).offset().top
   }, 500);
 });
}

</script>

<a href="https://github.com/zodiac/appspot-grading/tree/master/isicp"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a>

</body>
</html>
